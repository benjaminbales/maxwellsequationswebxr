<!DOCTYPE html>
  <html lang="en">
    <head>
      <title>three.js ar - hit test</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <link type="text/css" rel="stylesheet" href="main.css">
      <style>
        canvas { color : white;}
      </style>
    </head>
    <body>

      <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - hit test<br/>Enable chrome://flags/#webxr-ar-module<br/>Enable chrome://flags/#webxr-hit-test<br/>(Chrome Android 81+)
      </div>

      <!-- <script src="../../three.js/examples/js/libs/timeliner_gui.min.js"></script> -->
      
      <script type="module">
        // import * as THREE from '../js/third-party/three.js/build/three.module.js';
        import * as THREE from '../../three.js/src/Three.js'
        import { VRButton } from '../../three.js/examples/jsm/webxr/VRButton.js'
        import { GLTFLoader } from '../js/third-party/three.js/examples/jsm/loaders/GLTFLoader.js';
        import { RoughnessMipmapper } from '../../three.js/examples/jsm/utils/RoughnessMipmapper.js';
        import { ARButton } from './ARButton.js';
        import { TransformControls } from '../../three.js/examples/jsm/controls/TransformControls.js';
        import { TimelinerController } from '../../three.js/examples/jsm/animation/TimelinerController.js';

        var container;
        var camera, scene, renderer, control;
        var controller;
        // var transformControl;
        var mode = 0;
        var modeSelection = 0;  // helps cycle through ToggleGizmos

        var reticle;
        var sceneObjects = [];
        var MAX_OBJECTS = 1;
        var raycaster, mouse, intersected = [];
			  var tempMatrix = new THREE.Matrix4();

        // import spherical shell gltf from blender
        var loader = new GLTFLoader().setPath( '../media/gltf/sphericalshell/' );
        var sphericalshell;
        // loader.load( 'sphericalshell.gltf', function ( gltf ) {
        loader.load( 'sphericalshell.glb', function ( gltf ) {
          sphericalshell  = gltf.scene;
        } );

        // import sunflower
        loader.setPath('../media/gltf/sunflower/');
        var sunflower;
        loader.load('sunflower.gltf', function(gltf){
          sunflower = gltf.scene;
        })

        var hitTestSource = null;
        var hitTestSourceRequested = false;

        init();
        // animate();

        function init() {

          // create a container for the docs
          container = document.createElement( 'div' );
          // // append to the header? 
          document.body.appendChild(container);

          // create new THREE scene in this window? where?
          scene = new THREE.Scene();
          
          // setup camera.... Where?
          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 1000 );
          camera.position.set(0,0,5);
          // move camera 5 units on z?
          // camera.position.z = 5;

          var light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
          light.position.set(1,1,1);
          // light.position.set( 0.5, 1, 0.25 );
          scene.add( light );

          // Testing code
          var geometry = new THREE.BoxGeometry();
          var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          var cube = new THREE.Mesh( geometry, material );
          scene.add( cube );
          // testing code

          // render settings
          // var renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
          renderer = new THREE.WebGLRenderer();
          onWindowResize();
          // renderer.setPixelRatio( window.devicePixelRatio );
          // renderer.setSize( window.innerWidth, window.innerHeight );
          renderer.xr.enabled = true; 
          renderer.setAnimationLoop( render );
          document.body.appendChild( renderer.domElement );

          control = new TransformControls( camera, renderer.domElement);
          control.addEventListener( 'change', render);
          scene.add(control); // not sure if this will break without any attachment? we'll see?
          /*
          // append the button to the document? 
          document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );
          // only if the controller works? 
          */
          document.body.appendChild( VRButton.createButton( render ));
          
          
          var controller = renderer.xr.getController(0);         
          var lineGeometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
          
          var line = new THREE.Line( lineGeometry );
          line.name = 'line';
          line.scale.z = 5;
          
          controller.add(line.clone());

          // raycaster = new THREE.Raycaster();
          // var mouseDownEvent = { type: "mouseDown" };
          // .dispatchEvent(mouseDownEvent)

          raycaster = new THREE.Raycaster(); 
          mouse = new THREE.Vector2();

          controller.addEventListener( 'selectstart', function ( event ) {
            if(!reticle.visible){
              var ctrlr = event.target;
              var mouseDownEvent = new Event("mousedown", { bubbles: true, cancelable: false });
              // ctrlr.dispatchEvent(mouseDownEvent);
              renderer.domElement.dispatchEvent(mouseDownEvent);
              console.log("selectstart event fired");

              // var intersections = getIntersections( ctrlr );

              // if ( intersections.length > 0 ) {

              //   var intersection = intersections[ 0 ];

              //   tempMatrix.getInverse( ctrlr.matrixWorld );

              //   var object = intersection.object;

              //   var modes = ["scale", "translate", "rotate"];

              //   console.log("intersection.object is " + object);
                
              //   // transformControl.setMode(modes[++mode % 3]);  
              //   console.log("mode" + mode);
              //   console.log("modes[mode % 3] " + modes[mode % 3]);
              //   // console.log("transformControl.getMode() " + transformControl.getMode());

              //   object.matrix.premultiply( tempMatrix );
              //   object.matrix.decompose( object.position, object.quaternion, object.scale );
              //   // object.material.emissive.b = 1;
              //   // ctrlr.add( object );
              //   // scene.remove(object);

              //   // ctrlr.userData.selected = object;

              // }
            }
          });

          controller.addEventListener( 'selectend', function ( event ) {
            if(!reticle.visible){
              var ctrlr = event.target;
              var mouseUpEvent = new Event("mouseup", { bubbles: true, cancelable: false });
              // { type: "mouseup" , mode: "translate"};
              // ctrlr.dispatchEvent(mouseUpEvent);
              renderer.domElement.dispatchEvent(mouseUpEvent);
              console.log("selectend event fired");

              // if ( ctrlr.userData.selected !== undefined ) {

              //   var object = ctrlr.userData.selected;
              //   object.matrix.premultiply( ctrlr.matrixWorld );
              //   object.matrix.decompose( object.position, object.quaternion, object.scale );
              //   // object.material.emissive.b = 0;

              //   // ctrlr.remove(object);
              //   // scene.add(object);
              //   ctrlr.userData.selected = undefined;
              // }

              // cleanIntersected();

              // switch ( event.keyCode ) {
              //   case 17: // Ctrl
              //     transformControl.setTranslationSnap( null );
              //     transformControl.setRotationSnap( null );
              //     break;
              // }
            }
          });
          
          controller.addEventListener('select', function ( event) {
            if (reticle.visible) {

              var numSegments = 32;

              //define three.js sphere
              var sphereRadius = .1;
              var sphereGeometry = new THREE.SphereGeometry(sphereRadius, numSegments, numSegments);
              // var sphereMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
              var sphereMaterial = new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( '../media/gltf/sphericalshell/hubble.png' ) } );
              var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

              sphere.position.setFromMatrixPosition(reticle.matrix);
              sceneObjects.push(sphere);
              // sphere.name = "MySphere";

              scene.add(sphere);
              
              var transformControl = new TransformControls( camera, renderer.domElement );
              transformControl.addEventListener( 'change', render );
              transformControl.addEventListener('mouseDown', function(){
                console.log("Hello world, mouseDown event fired on transformControl!");
              });
              transformControl.setMode("rotate");
              transformControl.attach(sphere);
              scene.add(transformControl);

              // //add spherical shell
              // var sphere = new THREE.Object3D();
              // sphere.copy(sphericalshell);
              // sphere.applyMatrix4(reticle.matrix);
              // sceneObjects.push(sphere);
              // scene.add( sphere );

              //add sunflower
              // var snflwr = new THREE.Object3D();
              // snflwr.copy(sunflower);
              // snflwr.applyMatrix4(reticle.matrix);
              // sceneObjects.push(snflwr);
              // scene.add( snflwr );

              // //define probe axes
              // var axisLength = 0.5; 
              // var axisMaterial = new THREE.LineDashedMaterial({
              //   color: 0xffffff,
              //   linewidth: 3,
              //   scale: .1,
              //   dashSize: .1,
              //   gapSize: .1
              // });		

              // //probe x-axis
              // var xAxisPts = [];
              // xAxisPts.push(new THREE.Vector3(0, 0, 0));
              // xAxisPts.push(new THREE.Vector3(axisLength, 0, 0));
              // var xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPts);				
              // var xAxis = new THREE.Line(xAxisGeometry, axisMaterial);
              // xAxis.position.setFromMatrixPosition(reticle.matrix);
              // sphere.add(xAxis);
              // scene.add(xAxis);

              // //probe y-axis
              // var yAxisPts = [];
              // yAxisPts.push(new THREE.Vector3(0, 0, 0)); 
              // yAxisPts.push(new THREE.Vector3(0, axisLength, 0));
              // var yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPts);				
              // var yAxis = new THREE.Line(yAxisGeometry, axisMaterial);
              // yAxis.position.setFromMatrixPosition(reticle.matrix);
              // sphere.add(yAxis);
              // scene.add(yAxis);

            }
          });

          scene.add(controller);

          reticle = new THREE.Mesh(new THREE.SphereGeometry(.1, 32, 32), new THREE.MeshPhongMaterial({color: 0xff0000}));
          reticle.matrixAutoUpdate = false;
          reticle.visible = false;
          scene.add(reticle);

          window.addEventListener( 'resize', onWindowResize, false );

          window.addEventListener( 'keydown', function ( event ) {
            switch ( event.keyCode ) {

              case 81: // Q
                control.setSpace( control.space === "local" ? "world" : "local" );
                break;

              case 16: // Shift
                control.setTranslationSnap( 100 );
                control.setRotationSnap( THREE.MathUtils.degToRad( 15 ) );
                control.setScaleSnap( 0.25 );
                break;

              case 87: // W
                control.setMode( "translate" );
                break;

              case 69: // E
                control.setMode( "rotate" );
                break;

              case 82: // R
                control.setMode( "scale" );
                break;

              case 187:
              case 107: // +, =, num+
                control.setSize( control.size + 0.1 );
                break;

              case 189:
              case 109: // -, _, num-
                control.setSize( Math.max( control.size - 0.1, 0.1 ) );
                break;

              case 88: // X
                control.showX = ! control.showX;
                break;

              case 89: // Y
                control.showY = ! control.showY;
                break;

              case 90: // Z
                control.showZ = ! control.showZ;
                break;

              case 32: // Spacebar
                control.enabled = ! control.enabled;
                break;

            }
            });

          window.addEventListener( 'keyup', function ( event ) {
              switch ( event.keyCode ) {

                case 17: // Ctrl
                  control.setTranslationSnap( null );
                  control.setRotationSnap( null );
                  control.setScaleSnap( null );
                  break;

              }

              } );

          window.addEventListener( 'mousedown', CheckRayCast, false ); 
        }
       
      function CheckRayCast() 
      {  
        // calculate mouse position in normalized device coordinates 
        // (-1 to +1) for both components 
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1; 
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
        // perform raycast check from the camer from the mouse click on window
        raycaster.setFromCamera( mouse, camera ); 

        // calculate objects intersecting the picking ray 
        var intersects = raycaster.intersectObjects( scene.children ); 
        if( intersects.length > 0 )
        {
            if( control.attach != intersects[0].object )
            {
              // problem here?
              control.attach( intersects[0].object );
              // modeSelection = 0;
              ToggleGizmos();
            }
            else
            {
              console.log("cycle gizmos");
              ToggleGizmos();
            }
        }
        else
        {
          console.log("unassign controi.attach");
            control.attach = null;
        }
        // for ( var i = 0; i < intersects.length; i++ ) 
        // {
        //   intersects[ i ].object.material.color.set( 0xff0000 ); 
        // } 
      } 
    

        function ToggleGizmos(){
          
          modeSelection = modeSelection == 3 ? 1 : modeSelection + 1;
          switch ( modeSelection ) {

            // case 1: // Q
            // 	control.setSpace( control.space === "local" ? "world" : "local" );
            // 	break;
            case 1: // W
              control.setMode( "translate" );
              break;

            case 2: // E
              control.setMode( "rotate" );
              break;

            case 3: // R
              control.setMode( "scale" );
              break;
          }
        }
        
        function mouseDownEvent(){
          Console.log("Mouse event clicked!");
        }

        // when window resize, recaluatel camera aspect and update scene. 
        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }

        // set animation? What animation? 
        // function animate() {
        //   renderer.setAnimationLoop( render );
        // }


        function getIntersections( ctrlr ) {

          tempMatrix.identity().extractRotation( ctrlr.matrixWorld );

          raycaster.ray.origin.setFromMatrixPosition( ctrlr.matrixWorld );
          raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
          var intersections = [];
          if(sceneObjects.length > 0){
            intersections = raycaster.intersectObjects( sceneObjects);
          }
          return intersections;
        }

        function intersectObjects( ctrlr ) {

          // Do not highlight when already selected

          if ( ctrlr.userData.selected !== undefined ) return;

          var line = ctrlr.getObjectByName( 'line' );
          var intersections = getIntersections( ctrlr );

          if ( intersections.length > 0 ) {

            var intersection = intersections[ 0 ];

            var object = intersection.object;
            // object.material.emissive.r = 1;
            intersected.push( object );

            line.scale.z = intersection.distance;

          } else {

            line.scale.z = 5;

          }

        }

        function cleanIntersected() {

          while ( intersected.length ) {

            var object = intersected.pop();
            // object.material.emissive.r = 0;

          }

        }

        // function render(){
        //   renderer.render ( scene, camera);
        // }

        function render( timestamp, frame ) {

          // cleanIntersected();

          // intersectObjects(controller);

          if (frame) {
            var referenceSpace = renderer.xr.getReferenceSpace();
            var session = renderer.xr.getSession();

            if (hitTestSourceRequested === false) {
              session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
                session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {
                  hitTestSource = source;
                });
              });

              session.addEventListener( 'end', function () {
                hitTestSourceRequested = false;
                hitTestSource = null;
              });

              hitTestSourceRequested = true;
            }

            if (hitTestSource) {
              var hitTestResults = frame.getHitTestResults( hitTestSource );

              if (hitTestResults.length && sceneObjects.length < MAX_OBJECTS) {
                var hit = hitTestResults[0];
                reticle.visible = true;
                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
              } else {
                reticle.visible = false;
              }
            }
          }

          renderer.render( scene, camera );
        }
      </script>
    </body>
  </html>
