<!DOCTYPE html>
  <html lang="en">
    <head>
      <title>three.js ar - hit test</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <link type="text/css" rel="stylesheet" href="main.css">
      <style>
        canvas { color : white;}
      </style>
    </head>
    <body>

      <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - hit test<br/>Enable chrome://flags/#webxr-ar-module<br/>Enable chrome://flags/#webxr-hit-test<br/>(Chrome Android 81+)
      </div>

      <!-- <script src="../../three.js/examples/js/libs/timeliner_gui.min.js"></script> -->
      
      <script type="module">
        // import * as THREE from '../js/third-party/three.js/build/three.module.js';
        import * as THREE from '../../three.js/src/Three.js'
        // import { VRButton } from '../../three.js/examples/jsm/webxr/VRButton.js'
        // import { GLTFLoader } from '../js/third-party/three.js/examples/jsm/loaders/GLTFLoader.js';
        // import { RoughnessMipmapper } from '../../three.js/examples/jsm/utils/RoughnessMipmapper.js';
        import { ARButton } from '../../three.js/examples/jsm/webxr/ARButton.js';
        import { TransformControls } from '../../three.js/examples/jsm/controls/TransformControls.js';
        // import { TimelinerController } from '../../three.js/examples/jsm/animation/TimelinerController.js';
        // import { BoxLineGeometry } from '../../three.js/examples/jsm/geometries/BoxLineGeometry.js';
        import { XRControllerModelFactory } from '../../three.js/examples/jsm/webxr/XRControllerModelFactory.js';


        var container;
        var camera, scene, renderer, control;
        var controller;
        var controllerGrip;
        // var transformControl;
        var mode = 0;
        var modeSelection = 0;  // helps cycle through ToggleGizmos

        var reticle;
        var sceneObjects = [];
        var attached;
        var MAX_OBJECTS = 1;
        var raycaster, mouse, intersected = [];
			  var tempMatrix = new THREE.Matrix4();

        // import spherical shell gltf from blender
        // var loader = new GLTFLoader().setPath( '../media/gltf/sphericalshell/' );
        // var sphericalshell;
        // // loader.load( 'sphericalshell.gltf', function ( gltf ) {
        // loader.load( 'sphericalshell.glb', function ( gltf ) {
        //   sphericalshell  = gltf.scene;
        // } );

        // import sunflower
        // loader.setPath('../media/gltf/sunflower/');
        // var sunflower;
        // loader.load('sunflower.gltf', function(gltf){
        //   sunflower = gltf.scene;
        // })

        var hitTestSource = null;
        var hitTestSourceRequested = false;

        init();
        // animate();

      function init() 
      {

          // create a container for the docs
          container = document.createElement( 'div' );
          document.body.appendChild(container);

          // create new scene
          scene = new THREE.Scene();

          // setup camera
          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 1000 );
          camera.position.set(0,0,5);
          scene.add( camera) ;

          // var room = new THREE.LineSegments(
          //   new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),
          //   new THREE.LineBasicMaterial( { color: 0x808080 } )
          // );
          // scene.add( room );

          var light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
          light.position.set(1,1,1);
          // light.position.set( 0.5, 1, 0.25 );
          scene.add( light );

          // Testing code
          // createCube();

          // render settings
          // var renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
          renderer = new THREE.WebGLRenderer();
          onWindowResize();
          // renderer.setPixelRatio( window.devicePixelRatio );
          // renderer.setSize( window.innerWidth, window.innerHeight );
          renderer.xr.enabled = true; 
          renderer.setAnimationLoop( render );
          container.appendChild( renderer.domElement );
 
          
          controller = renderer.xr.getController(0);         
          var lineGeometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );
          
          // var line = new THREE.Line( lineGeometry );
          // line.name = 'line';
          // line.scale.z = 5;
          
          // controller.add(line.clone());

          // raycaster = new THREE.Raycaster();
          // var mouseDownEvent = { type: "mouseDown" };
          // .dispatchEvent(mouseDownEvent)

          raycaster = new THREE.Raycaster(); 
          mouse = new THREE.Vector2();

          document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );
          
          // controller.addEventListener( 'selectstart' , onSelectStart );
          // controller.addEventListener( 'selectend' , onSelectEnd );
          
          controller.addEventListener( 'select' , onSelect );
          scene.add(controller);

          reticle = new THREE.Mesh(new THREE.SphereGeometry(.1, 32, 32), new THREE.MeshPhongMaterial({color: 0xff0000}));
          reticle.matrixAutoUpdate = false;
          reticle.visible = false;
          scene.add(reticle);

          window.addEventListener( 'resize', onWindowResize, false );
          // window.addEventListener( 'mousedown', CheckRayCast, false ); 
      }

      function onSelect(){
         if (!reticle.visible) return;

          var numSegments = 32;

          //define three.js sphere
          var sphereRadius = .1;
          var sphereGeometry = new THREE.SphereGeometry(sphereRadius, numSegments, numSegments);
          // var sphereMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
          var sphereMaterial = new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( '../media/gltf/sphericalshell/hubble.png' ) } );
          var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

          sphere.position.setFromMatrixPosition(reticle.matrix);
          sceneObjects.push(sphere);
          // sphere.name = "MySphere";

          scene.add(sphere);
          
          var transformControl = new TransformControls( camera, renderer.domElement );
          transformControl.addEventListener( 'change', render );
          transformControl.addEventListener('mouseDown', function(){
            console.log("Hello world, mouseDown event fired on transformControl!");
          });
          transformControl.setMode("rotate");
          transformControl.attach(sphere);
          scene.add(transformControl);

          // //add spherical shell
          // var sphere = new THREE.Object3D();
          // sphere.copy(sphericalshell);
          // sphere.applyMatrix4(reticle.matrix);
          // sceneObjects.push(sphere);
          // scene.add( sphere );

          //add sunflower
          // var snflwr = new THREE.Object3D();
          // snflwr.copy(sunflower);
          // snflwr.applyMatrix4(reticle.matrix);
          // sceneObjects.push(snflwr);
          // scene.add( snflwr );

          // //define probe axes
          // var axisLength = 0.5; 
          // var axisMaterial = new THREE.LineDashedMaterial({
          //   color: 0xffffff,
          //   linewidth: 3,
          //   scale: .1,
          //   dashSize: .1,
          //   gapSize: .1
          // });		

          // //probe x-axis
          // var xAxisPts = [];
          // xAxisPts.push(new THREE.Vector3(0, 0, 0));
          // xAxisPts.push(new THREE.Vector3(axisLength, 0, 0));
          // var xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPts);				
          // var xAxis = new THREE.Line(xAxisGeometry, axisMaterial);
          // xAxis.position.setFromMatrixPosition(reticle.matrix);
          // sphere.add(xAxis);
          // scene.add(xAxis);

          // //probe y-axis
          // var yAxisPts = [];
          // yAxisPts.push(new THREE.Vector3(0, 0, 0)); 
          // yAxisPts.push(new THREE.Vector3(0, axisLength, 0));
          // var yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPts);				
          // var yAxis = new THREE.Line(yAxisGeometry, axisMaterial);
          // yAxis.position.setFromMatrixPosition(reticle.matrix);
          // sphere.add(yAxis);
          // scene.add(yAxis);
      }

      function onSelectStart(){
        this.userData.isSelected = true;  
        
        if(!reticle.visible){
              var ctrlr = event.target;
              var mouseDownEvent = new Event("mousedown", { bubbles: true, cancelable: false });
              // ctrlr.dispatchEvent(mouseDownEvent);
              renderer.domElement.dispatchEvent(mouseDownEvent);
              console.log("selectstart event fired");

              // var intersections = getIntersections( ctrlr );

              // if ( intersections.length > 0 ) {

              //   var intersection = intersections[ 0 ];

              //   tempMatrix.getInverse( ctrlr.matrixWorld );

              //   var object = intersection.object;

              //   var modes = ["scale", "translate", "rotate"];

              //   console.log("intersection.object is " + object);
                
              //   // transformControl.setMode(modes[++mode % 3]);  
              //   console.log("mode" + mode);
              //   console.log("modes[mode % 3] " + modes[mode % 3]);
              //   // console.log("transformControl.getMode() " + transformControl.getMode());

              //   object.matrix.premultiply( tempMatrix );
              //   object.matrix.decompose( object.position, object.quaternion, object.scale );
              //   // object.material.emissive.b = 1;
              //   // ctrlr.add( object );
              //   // scene.remove(object);

              //   // ctrlr.userData.selected = object;

              // }
            }
      }

      function onSelectEnd(){
        this.userData.isSelected = false;
        if(!reticle.visible){
              var ctrlr = event.target;
              var mouseUpEvent = new Event("mouseup", { bubbles: true, cancelable: false });
              // { type: "mouseup" , mode: "translate"};
              // ctrlr.dispatchEvent(mouseUpEvent);
              renderer.domElement.dispatchEvent(mouseUpEvent);
              console.log("selectend event fired");

              // if ( ctrlr.userData.selected !== undefined ) {

              //   var object = ctrlr.userData.selected;
              //   object.matrix.premultiply( ctrlr.matrixWorld );
              //   object.matrix.decompose( object.position, object.quaternion, object.scale );
              //   // object.material.emissive.b = 0;

              //   // ctrlr.remove(object);
              //   // scene.add(object);
              //   ctrlr.userData.selected = undefined;
              // }

              // cleanIntersected();

              // switch ( event.keyCode ) {
              //   case 17: // Ctrl
              //     transformControl.setTranslationSnap( null );
              //     transformControl.setRotationSnap( null );
              //     break;
              // }
            }
      }
       
      function CheckRayCast() 
      {  
        // calculate mouse position in normalized device coordinates 
        // (-1 to +1) for both components 
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1; 
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        
        // perform raycast check from the camer from the mouse click on window
        raycaster.setFromCamera( mouse, camera ); 

        // calculate objects intersecting the picking ray 
        var intersects = raycaster.intersectObjects( scene.children ); 
        if( intersects.length > 0 )
        {
            if( attached != intersects[0].object )
            {
              // problem here?
              AssignTransformControls(intersects[0].object);
              modeSelection = 0;  // problem.. this guy is being force to be stuck in a movement mode?
            }
        }
        else if ( attached != null )
        {
          // what happen if we allow player to double click? hmm
          console.log("Remove control from scene");
          scene.remove(control);
          attached = null;
        }
        else{
          createCube();
        }
      } 

      function AssignTransformControls( obj ){

        // if we have active control, we need to free that first before creating a new controls.
        if( control != null )
        { 
          scene.remove(control);  // there's hook to this guy here that interact with the object It was assigned... How to free this guy!
          control.detach();
          control.remove();
        }

        // create a new rotational control on local space on the object passed in.
        control = new TransformControls( camera, renderer.domElement);
        control.setMode("rotate");
        control.setSpace( "local" );
        control.addEventListener( 'change', render);
        scene.add(control); // not sure if this will break without any attachment? we'll see?
        control.attach( obj );
        attached = obj;
      }
  
      // function ToggleGizmos(){
        
      //   modeSelection = modeSelection == 3 ? 1 : modeSelection + 1;
      //   switch ( modeSelection ) {

      //     // case 1: // Q
      //     // 	control.setSpace( control.space === "local" ? "world" : "local" );
      //     // 	break;
      //     case 1: // W
      //       control.setMode( "translate" );
      //       break;

      //     case 2: // E
      //       control.setMode( "rotate" );
      //       break;

      //     case 3: // R
      //       control.setMode( "scale" );
      //       break;
      //   }
      // }
      
      function mouseDownEvent(){
        Console.log("Mouse event clicked!");
      }

        // when window resize, recaluatel camera aspect and update scene. 
        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setPixelRatio ( window.devicePixelRatio);
          renderer.setSize( window.innerWidth, window.innerHeight );
        }

        // set animation? What animation? 
        // function animate() {
        //   renderer.setAnimationLoop( render );
        // }
        
        function createCube( position )
        {
          var geometry = new THREE.BoxGeometry();
          var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          var cube = new THREE.Mesh( geometry, material );
          if( position != null )
            cube.position.set(position);
          scene.add( cube );
        }

        function getIntersections( ctrlr ) {

          tempMatrix.identity().extractRotation( ctrlr.matrixWorld );

          raycaster.ray.origin.setFromMatrixPosition( ctrlr.matrixWorld );
          raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
          var intersections = [];
          if(sceneObjects.length > 0){
            intersections = raycaster.intersectObjects( sceneObjects);
          }
          return intersections;
        }

        function intersectObjects( ctrlr ) {

          // Do not highlight when already selected

          if ( ctrlr.userData.selected !== undefined ) return;

          var line = ctrlr.getObjectByName( 'line' );
          var intersections = getIntersections( ctrlr );

          if ( intersections.length > 0 ) {

            var intersection = intersections[ 0 ];

            var object = intersection.object;
            // object.material.emissive.r = 1;
            intersected.push( object );

            line.scale.z = intersection.distance;

          } else {

            line.scale.z = 5;

          }

        }

        function cleanIntersected() {

          while ( intersected.length ) {

            var object = intersected.pop();
            // object.material.emissive.r = 0;

          }

        }

        // function render(){
        //   renderer.render ( scene, camera);
        // }

        function handleController( controller ){
          var userData = controller.userData;

          // cursor.set( 0, 0, - 0.2 ).applyMatrix4( controller.matrixWorld);

          if( userData.isSelected === true ){

          }
        }

        function handleGround(frame){
          if (!frame) return; 
          var referenceSpace = renderer.xr.getReferenceSpace();
            var session = renderer.xr.getSession();

            if (hitTestSourceRequested === false) {
              session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
                session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {
                  hitTestSource = source;
                });
              });

              session.addEventListener( 'end', function () {
                hitTestSourceRequested = false;
                hitTestSource = null;
              });

              hitTestSourceRequested = true;
            }

            if (hitTestSource) {
              var hitTestResults = frame.getHitTestResults( hitTestSource );

              if (hitTestResults.length && sceneObjects.length < MAX_OBJECTS) {
                var hit = hitTestResults[0];
                reticle.visible = true;
                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
              } else {
                reticle.visible = false;
              }
            }
        }

        function render( timestamp, frame ) {

          handleController(controller);
          // cleanIntersected();

          // intersectObjects(controller);
          handleGround(frame);
          
          renderer.render( scene, camera );
        }
      </script>
    </body>
  </html>
