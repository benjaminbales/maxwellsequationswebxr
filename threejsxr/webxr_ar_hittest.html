<!DOCTYPE html>
  <html lang="en">
    <head>
      <title>three.js ar - hit test</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <link type="text/css" rel="stylesheet" href="main.css">
    </head>
    <body>

      <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - hit test<br/>Enable chrome://flags/#webxr-ar-module<br/>Enable chrome://flags/#webxr-hit-test<br/>(Chrome Android 81+)
      </div>

      <script src="../../three.js/examples/js/libs/timeliner_gui.min.js"></script>
      
      <script type="module">

        import * as THREE from '../js/third-party/three.js/build/three.module.js';
        import { GLTFLoader } from '../js/third-party/three.js/examples/jsm/loaders/GLTFLoader.js';
        import { RoughnessMipmapper } from '../../three.js/examples/jsm/utils/RoughnessMipmapper.js';
        import { ARButton } from './ARButton.js';
        import { TransformControls } from '../../three.js/examples/jsm/controls/TransformControls.js';
        import { TimelinerController } from '../../three.js/examples/jsm/animation/TimelinerController.js';

        var container;
        var camera, scene, renderer;
        var controller;
        // var transformControl;
        var mode = 0;

        var reticle;
        var sceneObjects = [];
        var MAX_OBJECTS = 1;
        var raycaster, intersected = [];
			  var tempMatrix = new THREE.Matrix4();

        // import spherical shell gltf from blender
        var loader = new GLTFLoader().setPath( '../media/gltf/sphericalshell/' );
        var sphericalshell;
        // loader.load( 'sphericalshell.gltf', function ( gltf ) {
        loader.load( 'sphericalshell.glb', function ( gltf ) {
          sphericalshell  = gltf.scene;
        } );

        // import sunflower
        loader.setPath('../media/gltf/sunflower/');
        var sunflower;
        loader.load('sunflower.gltf', function(gltf){
          sunflower = gltf.scene;
        })

        var hitTestSource = null;
        var hitTestSourceRequested = false;

        init();
        animate();

        function init() {

          container = document.createElement( 'div' );
          document.body.appendChild( container );

          scene = new THREE.Scene();

          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );

          var light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
          light.position.set( 0.5, 1, 0.25 );
          scene.add( light );

          renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          renderer.xr.enabled = true;
          container.appendChild( renderer.domElement );

          document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

          controller = renderer.xr.getController(0);

          var lineGeometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

          var line = new THREE.Line( lineGeometry );
          line.name = 'line';
          line.scale.z = 5;

          controller.add(line.clone());

          raycaster = new THREE.Raycaster();
          // var mouseDownEvent = { type: "mouseDown" };
          // .dispatchEvent(mouseDownEvent)
          controller.addEventListener( 'selectstart', function ( event ) {
            if(!reticle.visible){
              var ctrlr = event.target;
              var mouseDownEvent = new Event("mousedown", { bubbles: true, cancelable: false });
              // ctrlr.dispatchEvent(mouseDownEvent);
              renderer.domElement.dispatchEvent(mouseDownEvent);
              console.log("selectstart event fired");

              // var intersections = getIntersections( ctrlr );

              // if ( intersections.length > 0 ) {

              //   var intersection = intersections[ 0 ];

              //   tempMatrix.getInverse( ctrlr.matrixWorld );

              //   var object = intersection.object;

              //   var modes = ["scale", "translate", "rotate"];

              //   console.log("intersection.object is " + object);
                
              //   // transformControl.setMode(modes[++mode % 3]);  
              //   console.log("mode" + mode);
              //   console.log("modes[mode % 3] " + modes[mode % 3]);
              //   // console.log("transformControl.getMode() " + transformControl.getMode());

              //   object.matrix.premultiply( tempMatrix );
              //   object.matrix.decompose( object.position, object.quaternion, object.scale );
              //   // object.material.emissive.b = 1;
              //   // ctrlr.add( object );
              //   // scene.remove(object);

              //   // ctrlr.userData.selected = object;

              // }
            }
          });

          controller.addEventListener( 'selectend', function ( event ) {
            if(!reticle.visible){
              var ctrlr = event.target;
              var mouseUpEvent = new Event("mouseup", { bubbles: true, cancelable: false });
              // { type: "mouseup" , mode: "translate"};
              // ctrlr.dispatchEvent(mouseUpEvent);
              renderer.domElement.dispatchEvent(mouseUpEvent);
              console.log("selectend event fired");

              // if ( ctrlr.userData.selected !== undefined ) {

              //   var object = ctrlr.userData.selected;
              //   object.matrix.premultiply( ctrlr.matrixWorld );
              //   object.matrix.decompose( object.position, object.quaternion, object.scale );
              //   // object.material.emissive.b = 0;

              //   // ctrlr.remove(object);
              //   // scene.add(object);
              //   ctrlr.userData.selected = undefined;
              // }

              // cleanIntersected();

              // switch ( event.keyCode ) {
              //   case 17: // Ctrl
              //     transformControl.setTranslationSnap( null );
              //     transformControl.setRotationSnap( null );
              //     break;
              // }
            }
          });

          controller.addEventListener('select', function ( event) {
            if (reticle.visible) {

              var numSegments = 32;

              //define three.js sphere
              var sphereRadius = .1;
              var sphereGeometry = new THREE.SphereGeometry(sphereRadius, numSegments, numSegments);
              // var sphereMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
              var sphereMaterial = new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( '../media/gltf/sphericalshell/hubble.png' ) } );
              var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

              sphere.position.setFromMatrixPosition(reticle.matrix);
              sceneObjects.push(sphere);
              // sphere.name = "MySphere";

              scene.add(sphere);
              
              var transformControl = new TransformControls( camera, renderer.domElement );
              transformControl.addEventListener( 'change', render );
              transformControl.addEventListener('mouseDown', function(){
                console.log("Hello world, mouseDown event fired on transformControl!");
              });
              transformControl.setMode("rotate");
              transformControl.attach(sphere);
              scene.add(transformControl);

              // //add spherical shell
              // var sphere = new THREE.Object3D();
              // sphere.copy(sphericalshell);
              // sphere.applyMatrix4(reticle.matrix);
              // sceneObjects.push(sphere);
              // scene.add( sphere );

              //add sunflower
              // var snflwr = new THREE.Object3D();
              // snflwr.copy(sunflower);
              // snflwr.applyMatrix4(reticle.matrix);
              // sceneObjects.push(snflwr);
              // scene.add( snflwr );

              // //define probe axes
              // var axisLength = 0.5; 
              // var axisMaterial = new THREE.LineDashedMaterial({
              //   color: 0xffffff,
              //   linewidth: 3,
              //   scale: .1,
              //   dashSize: .1,
              //   gapSize: .1
              // });		

              // //probe x-axis
              // var xAxisPts = [];
              // xAxisPts.push(new THREE.Vector3(0, 0, 0));
              // xAxisPts.push(new THREE.Vector3(axisLength, 0, 0));
              // var xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPts);				
              // var xAxis = new THREE.Line(xAxisGeometry, axisMaterial);
              // xAxis.position.setFromMatrixPosition(reticle.matrix);
              // sphere.add(xAxis);
              // scene.add(xAxis);

              // //probe y-axis
              // var yAxisPts = [];
              // yAxisPts.push(new THREE.Vector3(0, 0, 0)); 
              // yAxisPts.push(new THREE.Vector3(0, axisLength, 0));
              // var yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPts);				
              // var yAxis = new THREE.Line(yAxisGeometry, axisMaterial);
              // yAxis.position.setFromMatrixPosition(reticle.matrix);
              // sphere.add(yAxis);
              // scene.add(yAxis);

            }
          });

          scene.add(controller);

          reticle = new THREE.Mesh(new THREE.SphereGeometry(.1, 32, 32), new THREE.MeshPhongMaterial({color: 0xff0000}));
          reticle.matrixAutoUpdate = false;
          reticle.visible = false;
          scene.add(reticle);

          window.addEventListener( 'resize', onWindowResize, false );

        }

        function onWindowResize() {

          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {
          renderer.setAnimationLoop( render );
        }

        function getIntersections( ctrlr ) {

          tempMatrix.identity().extractRotation( ctrlr.matrixWorld );

          raycaster.ray.origin.setFromMatrixPosition( ctrlr.matrixWorld );
          raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
          var intersections = [];
          if(sceneObjects.length > 0){
            intersections = raycaster.intersectObjects( sceneObjects);
          }
          return intersections;
        }

        function intersectObjects( ctrlr ) {

          // Do not highlight when already selected

          if ( ctrlr.userData.selected !== undefined ) return;

          var line = ctrlr.getObjectByName( 'line' );
          var intersections = getIntersections( ctrlr );

          if ( intersections.length > 0 ) {

            var intersection = intersections[ 0 ];

            var object = intersection.object;
            // object.material.emissive.r = 1;
            intersected.push( object );

            line.scale.z = intersection.distance;

          } else {

            line.scale.z = 5;

          }

        }

        function cleanIntersected() {

          while ( intersected.length ) {

            var object = intersected.pop();
            // object.material.emissive.r = 0;

          }

        }

        function render( timestamp, frame ) {

          // cleanIntersected();

          // intersectObjects(controller);

          if (frame) {
            var referenceSpace = renderer.xr.getReferenceSpace();
            var session = renderer.xr.getSession();

            if (hitTestSourceRequested === false) {
              session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
                session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {
                  hitTestSource = source;
                });
              });

              session.addEventListener( 'end', function () {
                hitTestSourceRequested = false;
                hitTestSource = null;
              });

              hitTestSourceRequested = true;
            }

            if (hitTestSource) {
              var hitTestResults = frame.getHitTestResults( hitTestSource );

              if (hitTestResults.length && sceneObjects.length < MAX_OBJECTS) {
                var hit = hitTestResults[0];
                reticle.visible = true;
                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
              } else {
                reticle.visible = false;
              }
            }
          }

          renderer.render( scene, camera );
        }
      </script>
    </body>
  </html>
