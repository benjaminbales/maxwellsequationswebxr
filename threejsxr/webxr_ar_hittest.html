<!DOCTYPE html>
  <html lang="en">
    <head>
      <title>three.js ar - hit test</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <link type="text/css" rel="stylesheet" href="main.css">
    </head>
    <body>

      <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - hit test<br/>Enable chrome://flags/#webxr-ar-module<br/>Enable chrome://flags/#webxr-hit-test<br/>(Chrome Android 81+)
      </div>

      <script src="../../three.js/examples/js/libs/timeliner_gui.min.js"></script>
      
      <script type="module">

        import * as THREE from '../js/third-party/three.js/build/three.module.js';
        import { GLTFLoader } from '../js/third-party/three.js/examples/jsm/loaders/GLTFLoader.js';
        import { RoughnessMipmapper } from '../../three.js/examples/jsm/utils/RoughnessMipmapper.js';
        import { ARButton } from './ARButton.js';
        import { TransformControls } from './TransformControls.js';
        import { TimelinerController } from '../../three.js/examples/jsm/animation/TimelinerController.js';

        var container;
        var camera, scene, renderer;
        var controller;
        // var transformControl;
        var mode = 0;

        var reticle;
        var spheres = [];
        var transformControls = [];
        var MAX_OBJECTS = 1;
        var raycaster, intersected = [];
			  var tempMatrix = new THREE.Matrix4();

        // import spherical shell gltf from blender
        var loader = new GLTFLoader().setPath( '../media/gltf/sphericalshell/' );
        var sphericalshell;
        // loader.load( 'sphericalshell.gltf', function ( gltf ) {
        loader.load( 'sphericalshell.glb', function ( gltf ) {
          sphericalshell  = gltf.scene;
        } );

        // import sunflower
        loader.setPath('../media/gltf/sunflower/');
        var sunflower;
        loader.load('sunflower.gltf', function(gltf){
          sunflower = gltf.scene;
        })

        var hitTestSource = null;
        var hitTestSourceRequested = false;

        init();
        animate();

        function init() {

          container = document.createElement( 'div' );
          document.body.appendChild( container );

          scene = new THREE.Scene();

          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );

          var light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
          light.position.set( 0.5, 1, 0.25 );
          scene.add( light );

          renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          renderer.xr.enabled = true;
          container.appendChild( renderer.domElement );

          document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

          controller = renderer.xr.getController(0);

          var lineGeometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

          var line = new THREE.Line( lineGeometry );
          line.name = 'line';
          line.scale.z = 5;

          controller.add(line.clone());

          raycaster = new THREE.Raycaster();

          // controller.addEventListener( 'selectstart', function ( event ) {
            // if(!reticle.visible){
              // var ctrlr = event.target;

              // var mouseDownEvent = new Event("mousedown", { bubbles: true, cancelable: false });

              //I don't think renderer.domElement responds to xr select events.  Only the controller does this. 
              // renderer.domElement.dispatchEvent(mouseDownEvent);

              // console.log("selectstart event fired");

              // var intersections = getIntersections( ctrlr );

              // if ( intersections.length > 0 ) {

              //   var intersection = intersections[ 0 ];

              //   tempMatrix.getInverse( ctrlr.matrixWorld );

              //   var object = intersection.object;

                // var modes = ["off", "translate", "rotate", "scale"];

                // console.log("intersection.object is " + object);

                // for(let control of transformControls){
                //   if(++mode % 4 > 0){
                //     control.enabled = true;
                //     control.setMode(modes[mode % 4]);
                //   }else{
                //     control.enabled = false;
                //   }
                // }

                // console.log("mode" + mode);
                // console.log("modes[mode % 3] " + modes[mode % 3]);
                // console.log("transformControl.getMode() " + transformControl.getMode());

                // object.matrix.premultiply( tempMatrix );

                // object.matrix.decompose( object.position, object.quaternion, object.scale );

                // ctrlr.add( object );

                // scene.remove(object);

                // ctrlr.userData.selected = object;

              // }
            // }
          // });

          // controller.addEventListener( 'selectend', function ( event ) {
          //   if(!reticle.visible){
              // var ctrlr = event.target;

              // var mouseUpEvent = new Event("mouseup", { bubbles: true, cancelable: false });

              // renderer.domElement.dispatchEvent(mouseUpEvent);

              // console.log("selectend event fired");

              // if ( ctrlr.userData.selected !== undefined ) {

              //   var object = ctrlr.userData.selected;
              //   object.matrix.premultiply( ctrlr.matrixWorld );
              //   object.matrix.decompose( object.position, object.quaternion, object.scale );

              //   ctrlr.remove(object);
              //   scene.add(object);
              //   ctrlr.userData.selected = undefined;
              // }

              // cleanIntersected();

              // switch ( event.keyCode ) {
              //   case 17: // Ctrl
              //     transformControl.setTranslationSnap( null );
              //     transformControl.setRotationSnap( null );
              //     break;
              // }
            // }
          // });

          controller.addEventListener('select', function ( event) {
            if (reticle.visible) {

              var numSegments = 32;

              //define three.js sphere
              var sphereRadius = .1;
              var sphereGeometry = new THREE.SphereGeometry(sphereRadius, numSegments, numSegments);
              // var sphereMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
              var sphereMaterial = new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( '../media/gltf/sphericalshell/hubble.png' ) } );
              var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

              sphere.position.setFromMatrixPosition(reticle.matrix);
              sphere.name = "MySphere";
              spheres.push(sphere);

              scene.add(sphere);
              
              var transformControl = new TransformControls( camera, renderer.domElement, controller);
              transformControl.addEventListener( 'change', render );
              transformControl.setMode("rotate");
              transformControl.attach(sphere);
              transformControl.name = "MyTransformControl";
              transformControls.push(transformControl);
              scene.add(transformControl);

              // //add spherical shell
              // var sphere = new THREE.Object3D();
              // sphere.copy(sphericalshell);
              // sphere.applyMatrix4(reticle.matrix);
              // spheres.push(sphere);
              // scene.add( sphere );

              //add sunflower
              // var snflwr = new THREE.Object3D();
              // snflwr.copy(sunflower);
              // snflwr.applyMatrix4(reticle.matrix);
              // spheres.push(snflwr);
              // scene.add( snflwr );

              // //define probe axes
              // var axisLength = 0.5; 
              // var axisMaterial = new THREE.LineDashedMaterial({
              //   color: 0xffffff,
              //   linewidth: 3,
              //   scale: .1,
              //   dashSize: .1,
              //   gapSize: .1
              // });		

              // //probe x-axis
              // var xAxisPts = [];
              // xAxisPts.push(new THREE.Vector3(0, 0, 0));
              // xAxisPts.push(new THREE.Vector3(axisLength, 0, 0));
              // var xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPts);				
              // var xAxis = new THREE.Line(xAxisGeometry, axisMaterial);
              // xAxis.position.setFromMatrixPosition(reticle.matrix);
              // sphere.add(xAxis);
              // scene.add(xAxis);

              // //probe y-axis
              // var yAxisPts = [];
              // yAxisPts.push(new THREE.Vector3(0, 0, 0)); 
              // yAxisPts.push(new THREE.Vector3(0, axisLength, 0));
              // var yAxisGeometry = new THREE.BufferGeometry().setFromPoints(yAxisPts);				
              // var yAxis = new THREE.Line(yAxisGeometry, axisMaterial);
              // yAxis.position.setFromMatrixPosition(reticle.matrix);
              // sphere.add(yAxis);
              // scene.add(yAxis);

            }
          });

          scene.add(controller);

          reticle = new THREE.Mesh(new THREE.SphereGeometry(.1, 32, 32), new THREE.MeshPhongMaterial({color: 0xff0000}));
          reticle.matrixAutoUpdate = false;
          reticle.visible = false;
          scene.add(reticle);

          window.addEventListener( 'resize', onWindowResize, false );

        }

        function onWindowResize() {

          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {
          renderer.setAnimationLoop( render );
        }

        function getIntersections( ctrlr ) {
          tempMatrix.identity().extractRotation( ctrlr.matrixWorld );
          raycaster.ray.origin.setFromMatrixPosition( ctrlr.matrixWorld );
          raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );
          // return raycaster.intersectObjects(spheres);
          return raycaster.intersectObjects(scene.children);
        }

        function intersectObjects( ctrlr ) {

          // Do not highlight when already selected

          if ( ctrlr.userData.selected !== undefined ) return;

          // var line = ctrlr.getObjectByName( 'line' );
          var intersections = getIntersections( ctrlr );

          if ( intersections.length > 0 ) {
            var intersection = intersections[0];
            var object = intersection.object; 
            // //benb
            console.log("object.name " + object.name);
            intersected.push(object);

            // line.scale.z = intersection.distance;
          } 
          // else {
          //   line.scale.z = 5;
          // }
        }

        function cleanIntersected() {

          while ( intersected.length ) {

            var object = intersected.pop();

          }

        }

        function render( timestamp, frame ) {

          cleanIntersected();

          intersectObjects(controller);

          if (frame) {
            var referenceSpace = renderer.xr.getReferenceSpace();
            var session = renderer.xr.getSession();

            if (hitTestSourceRequested === false) {
              session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
                session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {
                  hitTestSource = source;
                });
              });

              session.addEventListener( 'end', function () {
                hitTestSourceRequested = false;
                hitTestSource = null;
              });

              hitTestSourceRequested = true;
            }

            if (hitTestSource) {
              var hitTestResults = frame.getHitTestResults( hitTestSource );

              if (hitTestResults.length && spheres.length < MAX_OBJECTS) {
                var hit = hitTestResults[0];
                reticle.visible = true;
                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
              } else {
                reticle.visible = false;
              }
            }
          }

          renderer.render( scene, camera );
        }
      </script>
    </body>
  </html>
